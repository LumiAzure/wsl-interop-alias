#!/bin/zsh

# Set log level (default to none). Acceptable values: NONE, INFO, DEBUG
LOG_LEVEL=${WSL_ALIAS_LOG_LEVEL:-NONE}

# Function to log messages based on log level
log() {
  local level=$1
  shift
  local message=$@
  case "$LOG_LEVEL" in
    DEBUG)
      echo "[$level] $message"
      ;;
    INFO)
      [[ "$level" == "INFO" ]] && echo "[$level] $message"
      ;;
  esac
}

# Check if the script is running in WSL by checking the WSL_DISTRO_NAME environment variable
if [ -z "$WSL_DISTRO_NAME" ]; then
  log INFO "This script is intended to run only in WSL (Windows Subsystem for Linux). Exiting."
  return 1
fi

# Define the configuration file path and cache file
CONFIG_FILE="$HOME/.config/wsl.alias"
CACHE_FILE="$HOME/.cache/wsl_alias/wsl.alias.cache"
CACHE_TIMESTAMP_FILE="$HOME/.cache/wsl_alias/wsl.alias.cache.timestamp"

# Check if the configuration file exists
if [ ! -f "$CONFIG_FILE" ]; then
  log INFO "Configuration file $CONFIG_FILE does not exist. Creating default configuration file."
  mkdir -p "$(dirname "$CONFIG_FILE")"
  mkdir -p "$(dirname "$CACHE_FILE")"
  echo "code=code" > "$CONFIG_FILE"
  echo "cmd=cmd.exe" >> "$CONFIG_FILE"
  echo "exp=explorer.exe" >> "$CONFIG_FILE"
  echo "notepad=notepad.exe" >> "$CONFIG_FILE"
  log INFO "Default configuration file created at $CONFIG_FILE."
fi

# Check if the cache needs to be regenerated by comparing the modification time of the configuration file
if [ ! -f "$CACHE_TIMESTAMP_FILE" ] || [ "$CONFIG_FILE" -nt "$CACHE_TIMESTAMP_FILE" ]; then
  log INFO "Cache is outdated or does not exist. Regenerating cache."

  # Iterate through each line in the configuration file and process the aliases
  while IFS= read -r line; do
    # Skip empty lines and comments
    [[ -z "$line" || "$line" =~ ^#.* ]] && continue

    # Parse alias and Windows command
    alias_name=$(echo "$line" | cut -d'=' -f1)
    windows_cmd=$(echo "$line" | cut -d'=' -f2)

    log DEBUG "Processing alias: $alias_name -> $windows_cmd"

    # Use cmd.exe to find the program path
    win_path=$("/mnt/c/Windows/System32/cmd.exe" /c "where $windows_cmd" 2>/dev/null </dev/null | sed 's/\r//g; s/\\/\//g')

    if [[ -z "$win_path" ]]; then
      log INFO "Unable to find the path for command $windows_cmd, skipping."
      continue
    fi

    # Convert Windows path to WSL path and escape spaces
    wsl_path=$(wslpath "$(echo $win_path | head -n 1)" | sed 's/ /\\ /g')

    # Add alias and store it in the cache file
    echo "alias $alias_name=\"$wsl_path\"" >> "$CACHE_FILE"
    log INFO "Alias added: $alias_name -> $wsl_path"

  done < "$CONFIG_FILE"

  # Update the cache timestamp to prevent unnecessary regeneration in the future
  touch "$CACHE_TIMESTAMP_FILE"
else
  log INFO "Cache is up to date. Using cached aliases."
fi

# Load aliases from the cache file
if [ -f "$CACHE_FILE" ]; then
  source "$CACHE_FILE"
  log INFO "Aliases loaded from cache."
else
  log INFO "No aliases found in cache."
fi

unset CONFIG_FILE
unset CACHE_FILE
unset CACHE_TIMESTAMP_FILE
unset line
unset alias_name
unset windows_cmd
unset win_path
unset wsl_path
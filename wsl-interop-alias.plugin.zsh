#!/usr/bin/env zsh

# Set log level (default to none). Acceptable values: NONE, INFO, DEBUG
LOG_LEVEL=${WSL_ALIAS_LOG_LEVEL:-NONE}

# Function to log messages based on log level
log() {
  local level=$1
  shift
  local message=$@
  case "$LOG_LEVEL" in
    DEBUG)
      echo "[$level] $message"
      ;;
    INFO)
      [[ "$level" == "INFO" ]] && echo "[$level] $message"
      ;;
  esac
}

# Check if the script is running in WSL by checking the WSL_DISTRO_NAME environment variable
if [ -z "$WSL_DISTRO_NAME" ]; then
  log INFO "This script is intended to run only in WSL (Windows Subsystem for Linux). Exiting."
  return 1
fi

# Define the configuration file path and cache file
CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/wsl_interop_func.conf"
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/wsl_interop_func"
TIME_STAMP="$CACHE_DIR/wsl_interop_func.timestamp"
LINK_DIR="$CACHE_DIR/links"

# Check if the configuration file exists
if [ ! -f "$CONFIG_FILE" ]; then
  log INFO "Configuration file $CONFIG_FILE does not exist. Creating default configuration file."
  mkdir -p "$(dirname "$CONFIG_FILE")"
  echo "code=code" > "$CONFIG_FILE"
  echo "cmd.exe=cmd.exe" >> "$CONFIG_FILE"
  echo "exp=explorer.exe" >> "$CONFIG_FILE"
  echo "notepad=notepad.exe" >> "$CONFIG_FILE"
  log INFO "Default configuration file created at $CONFIG_FILE."
fi

# Check if the cache needs to be regenerated by comparing the modification time of the configuration file
if [ ! -f "$TIME_STAMP" ] || [ "$CONFIG_FILE" -nt "$TIME_STAMP" ]; then
  log INFO "Cache is outdated or does not exist. Regenerating cache."

  # Clear the cache file
  mkdir -p "$LINK_DIR"
  rm -rf "$LINK_DIR/*"
  echo "# Symlinks created by xht308/wsl-interop-alias" > "$TIME_STAMP"
  echo "# This file is automatically generated. Do not edit." >> "$TIME_STAMP"
  echo "# Last updated: $(date)" >> "$TIME_STAMP"

  # Iterate through each line in the configuration file and create symlinks
  while IFS= read -r line; do
    # Skip empty lines and comments
    [[ -z "$line" || "$line" =~ ^#.* ]] && continue

    # Parse func name and Windows command
    local func_name=$(echo "$line" | cut -d'=' -f1)
    local windows_cmd=$(echo "$line" | cut -d'=' -f2)

    log DEBUG "Processing shim function: $func_name -> $windows_cmd"

    # Use cmd.exe to find the program path
    local win_path=$("/mnt/c/Windows/System32/cmd.exe" /c "where $windows_cmd" 2>/dev/null </dev/null | sed 's/\r//g; s/\\/\//g')

    if [[ -z "$win_path" ]]; then
      log INFO "Unable to find the path for command $windows_cmd, skipping."
      continue
    fi

    # Convert Windows path to WSL path and escape spaces
    local wsl_path=$(wslpath "$(echo $win_path | head -n 1)")

    # Create a symlink to run the Windows command in WSL
    ln -sf "$wsl_path" "$LINK_DIR/$func_name"
    log DEBUG "Symlink created: $LINK_DIR/$func_name"

  done < "$CONFIG_FILE"

else
  log INFO "Cache is up to date. Using cached symlinks."
fi

# Load symlinks from the cache directory
if [ -d "$LINK_DIR" ]; then
  path+=("$LINK_DIR")
  log INFO "Symlinks loaded from cache directory: $LINK_DIR"
else
  log INFO "No symlinks found in cache."
fi

unset CONFIG_FILE
unset CACHE_DIR
unset TIME_STAMP
unset LINK_DIR
unset line

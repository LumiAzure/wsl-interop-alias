#!/usr/bin/env zsh

# Set log level (default to none). Acceptable values: NONE, INFO, DEBUG
LOG_LEVEL=${WSL_ALIAS_LOG_LEVEL:-NONE}

# Function to log messages based on log level
log() {
  local level=$1
  shift
  local message=$@
  case "$LOG_LEVEL" in
    DEBUG)
      echo "[$level] $message"
      ;;
    INFO)
      [[ "$level" == "INFO" ]] && echo "[$level] $message"
      ;;
  esac
}

# Check if the script is running in WSL by checking the WSL_DISTRO_NAME environment variable
if [ -z "$WSL_DISTRO_NAME" ]; then
  log INFO "This script is intended to run only in WSL (Windows Subsystem for Linux). Exiting."
  return 1
fi

# Define the configuration file path and cache file
CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/wsl_interop_func.conf"
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/wsl_interop_func"
CACHE_FILE="$CACHE_DIR/wsl_interop_func.cache"
FUNC_CACHE_DIR="$CACHE_DIR/functions"

# Check if the configuration file exists
if [ ! -f "$CONFIG_FILE" ]; then
  log INFO "Configuration file $CONFIG_FILE does not exist. Creating default configuration file."
  mkdir -p "$(dirname "$CONFIG_FILE")"
  echo "code=code" > "$CONFIG_FILE"
  echo "cmd.exe=cmd.exe" >> "$CONFIG_FILE"
  echo "exp=explorer.exe" >> "$CONFIG_FILE"
  echo "notepad=notepad.exe" >> "$CONFIG_FILE"
  log INFO "Default configuration file created at $CONFIG_FILE."
fi

# Check if the cache needs to be regenerated by comparing the modification time of the configuration file
if [ ! -f "$CACHE_FILE" ] || [ "$CONFIG_FILE" -nt "$CACHE_FILE" ]; then
  log INFO "Cache is outdated or does not exist. Regenerating cache."

  # Clear the cache file
  mkdir -p "$(dirname "$CACHE_FILE")"
  rm -rf "$FUNC_CACHE_DIR"
  mkdir -p "$FUNC_CACHE_DIR"
  echo "#!/usr/bin/env zsh" > "$CACHE_FILE"
  echo "# Cached functions created by xht308/wsl-interop-alias" >> "$CACHE_FILE"
  echo "# This file is automatically generated. Do not edit." >> "$CACHE_FILE"
  echo "# Last updated: $(date)" >> "$CACHE_FILE"
  echo "fpath+=($FUNC_CACHE_DIR)" >> "$CACHE_FILE"

  # Iterate through each line in the configuration file and process the shim functions
  while IFS= read -r line; do
    # Skip empty lines and comments
    [[ -z "$line" || "$line" =~ ^#.* ]] && continue

    # Parse func name and Windows command
    func_name=$(echo "$line" | cut -d'=' -f1)
    windows_cmd=$(echo "$line" | cut -d'=' -f2)

    log DEBUG "Processing shim function: $func_name -> $windows_cmd"

    # Use cmd.exe to find the program path
    win_path=$("/mnt/c/Windows/System32/cmd.exe" /c "where $windows_cmd" 2>/dev/null </dev/null | sed 's/\r//g; s/\\/\//g')

    if [[ -z "$win_path" ]]; then
      log INFO "Unable to find the path for command $windows_cmd, skipping."
      continue
    fi

    # Convert Windows path to WSL path and escape spaces
    wsl_path=$(wslpath "$(echo $win_path | head -n 1)")

    # Create a shim function to run the Windows command in WSL
    echo "#!/usr/bin/env zsh" > "$FUNC_CACHE_DIR/$func_name"
    echo "# Shim function generated by xht308/wsl-interop-alias" >> "$FUNC_CACHE_DIR/$func_name"
    echo "# Last updated: $(date)" >> "$FUNC_CACHE_DIR/$func_name"
    echo "\"$wsl_path\" \"\$@\"" >> "$FUNC_CACHE_DIR/$func_name"
    chmod +x "$FUNC_CACHE_DIR/$func_name"
    log DEBUG "Shim function created: $FUNC_CACHE_DIR/$func_name"

    # Add shim function and load it in the cache file
    echo "[[ ! \$(command -v $func_name) ]] && autoload -U $func_name" >> "$CACHE_FILE"
    log INFO "Shim function added: $func_name -> $wsl_path"

  done < "$CONFIG_FILE"

else
  log INFO "Cache is up to date. Using cached shim functions."
fi

# Load shim functions from the cache file
if [ -f "$CACHE_FILE" ]; then
  source "$CACHE_FILE"
  log INFO "Shim functions loaded from cache."
else
  log INFO "No shim functions found in cache."
fi

unset CONFIG_FILE
unset CACHE_DIR
unset CACHE_FILE
unset CACHE_TIMESTAMP_FILE
unset FUNC_CACHE_DIR
unset line
unset func_name
unset windows_cmd
unset win_path
unset wsl_path